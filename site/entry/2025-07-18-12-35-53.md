---
title: haskell.nixでテストが無いパッケージもnix flake checkでチェックする
updated: 2025-09-10T12:59:16+09:00
---

# 背景

前回、
[haskell.nixでのプロジェクト環境でnix flake checkでPostgreSQLへのアクセスを含むテストを実行する方法 - ncaq](https://www.ncaq.net/2025/07/10/21/54/44/)
でテストの実行環境を`nix flake check`に統一しました。
そうしたら20分ぐらいかかることもあるCIの実行時間をキャッシュが存分に効いているときは4分ぐらいに短縮される嬉しい結果を得ました。

しかしその後問題が起きて、
`cabal build`ではエラーになるのに、
`nix flake check`ではエラーにならないという現象が発生しました。
その結果CIが通るからマージしたのにmasterブランチでビルドが通らないという事態が発生しました。

# 原因

原因を調べてみました。
絶対にエラーが発生するように、
該当するパッケージの必要な関数を削除してみたりしました。
そうしても`nix flake check`ではエラーにならないことを確認しました。

しかし移行するときに、
cabalでビルドエラーが起きたら`nix flake check`でもエラーになることは確認したのですが。

その前に確認したときにエラーを起こしたパッケージでビルドエラーを起こしてみたら、
`nix flake check`でちゃんとエラーになることが確認できました。

パッケージの違いで何が起きているのか、
もう少し詳しく原因を調査してみたところ、
テストが定義されていないパッケージは`nix flake check`でビルドされないことを知りました。

`nix flake show`でリストに載っていないことが分かりやすく確認できます。

`nix flake check`の哲学的にはそれで良いんだろうか。
ビルドできるかどうかは`nix build`で確認するべきとか?
でもそれは二度手間な気がします。

# 解決

とりあえず以下のように`checks`に`packages`を全部追加してやるだけで解決しました。
雑に追加するだけで重複とかはしないようです。

```nix
checks =
  flake.checks
  // flake.packages # テストがないパッケージもビルドしてエラーを検出する。
  // {
    formatting = treefmtEval.config.build.check self;
  };
```

これでついでにlibだけではなくexeもチェックされるようになります。

# 疑問

このようなことをするのは普通なのでしょうか?
最初から含まれても良い気がします。

`hydraJobs`のセクションなら最初から含まれているから、
それを使うべきなのかも?
しかしhydra用の機能をGitHub Actionsに使うのは乱用な気がします。
それにローカルでも`nix flake check`でまとめてチェックできるようにしておいた方が色々と便利だと思います。

# 順序大切

後で気がついたのですがこの順序は大変に問題です。
`flake.checks`の後ろに`flake.packages`を追加しているので、
テストのチェックがテスト実行ではなくビルドになってしまいます。
以下のようにちゃんと順序を考えましょう。

```nix
checks =
  flake.packages # テストがないパッケージもビルドしてエラーを検出する。順序大切。
  // flake.checks
  // {
    formatting = treefmtEval.config.build.check self;
  };
```
