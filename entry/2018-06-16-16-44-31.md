---
title: JavaScriptでtypeof x === 'undefined'を使わないで欲しい理由
---

何故嫌なのか説明します.

# nullを弾けない

~~~js
> typeof null
'object'
~~~

となります.

undefinedの場合弾いて,nullの場合許容したい時があるでしょうか.
私はほとんどそんなものは見たことがありませんし,それはしばしば設計ミスを示しています.
一般的にnullも同じく弾くべきです.

変数のフィールドを参照した際のTypeErrorはundefinedでもnullでも起きるため,両者を弾く意義は大いにあります.

# falseを弾けない

~~~js
> typeof false
'boolean'
~~~

undefinedとnullを弾いてfalseを許容するプログラムは実際見たことがありますが,
これもややこしく設計ミスの可能性が高いです.

意図した場合だとしても,false以外を弾くなら`x === false`とした方が意図が明白です.

# 空文字列を弾けない

~~~js
> typeof ''
'string'
~~~

undefinedとnullを許容しないで空文字列を許容するプログラムは割と見ますし,設計ミスではないこともよくあります.
`Array#join`とかですね.

いや,`Array#join`に引数指定しないとセパレータが`','`になるのは設計ミスか?
しばしば悩まされていますし.

どれも許容しない方式で書いた方がわかりやすいです.

# タイプミスを疑ってしまう

~~~js
> u = undefined
undefined
> typeof u === 'undefinde'
false
~~~

バグ調査の時こういうつまらないミスがないか確認するのが手間.
ですが,ESLintはこれ警告してくれるのでこれはあまり理由にならないかもしれません.

# 素直にBooleanに変換した方が短い

これまでの文章を踏まえて

~~~js
if(typeof x === 'undefined')
~~~

より

~~~js
if(x)
~~~

と書いたほうが読む側にとっても楽です.

しかしこれにも問題があるにはあります.

JavaScriptでは

* 0
* -0
* null
* false
* NaN
* undefined
* ''

はfalseに変換されます.

> 値が省略された場合や、値が 0, -0, null, false, NaN, undefined あるいは空文字列 ("") であった場合、オブジェクトは false の初期値を持ちます。
>
> [Boolean - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Boolean)

以下問題とその解決策を書いていきます.

## 0がfalseになる問題

~~~js
> Boolean(0)
false
~~~

0はfalseとして変換されます.

undefinedかnull以外の数値もしくはオブジェクトを期待しているときは以下のように書きましょう.

~~~js
if (Number.isInteger(x) || x)
~~~

整数のみを期待している時は以下の方が違う値も弾けてなおかつシンプルで良いですね.

~~~js
if (Number.isInteger(x))
~~~

浮動小数点数も受け入れたい場合は`Number.isFinite`で.

~~~js
> Number.isFinite(0.1)
true
~~~

この場合NaNも弾かれますがundefinedがダメでNaNが良い時が存在するのか怪しい.

~~~js
> Number.isInteger(NaN)
false
~~~

存在したとしてその時だけ`Number.isNaN`をorに入れて許可すれば良いのではないでしょうか.

## ''がfalseになる問題

~~~js
> Boolean('')
false
~~~

先程も述べたようにundefinedは非許容で空文字列は許容するのは設計ミスである疑いが強いです.

デフォルト引数や`x || ''`で空文字列を指定でもしておけば良いと思います.

# どうしてもundefinedのみを弾きたい時

引数の省略を検知したい時にあるかもしれません.

そういう時でも以下のように書いたほうが簡潔です.

~~~js
if (x === undefined)
~~~

undefinedは書き換えられられる可能性がある?
もはや古代であるES5から書き換え不能なので気にしなくて良いです.
ローカルスコープのundefinedをシャドウするのは明らかに意図があるのでむしろ影響がある方が良いのではないでしょうか.

`if (x)`を使いたくない時でも面倒なtypeofは使わないで素直に`x === undefined`を使いましょう.

# でもtypeofは変数が宣言されていない時もエラーを出さないから便利では?

それはそうですね.

しかし,MDNに書かれている通り,JavaScriptは字句的スコープの言語です.

> いずれにしても、この種のテクニックは避けるべきです。JavaScript は静的スコープの言語なので、変数が宣言されているか知りたければ、囲んでいるコンテキスト内でその変数が宣言されているか見ればいいのです。唯一の例外はグローバルスコープですが、グローバルスコープはグローバルオブジェクトに束縛されれているため、グローバルなコンテキスト内に変数が存在するか確認したければ、グローバルオブジェクト上のプロパティの存在を確認する (例えば in 演算子を使って) ことで行えます。
>
> [undefined - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/undefined)

モジュール化されたJavaScriptではグローバルスコープも含めて定義されていない変数はESLintで静的検証できます.

`require`も`import`も使えない環境で開発してる?
大変そうですね.

そういう時,MDNでは`in`を使ったグローバルスコープのルックアップを参照を推奨していますが,undefinedやnull値が入ったプロパティを弾けないので私は推奨しません.

~~~js
> window = {a: null, b: undefined}
{ a: null, b: undefined }
> 'a' in window
true
> 'b' in window
true
> 'c' in window
false
~~~

素直にwindowを参照すれば良いでしょう.

~~~js
> window.a
null
> window.b
undefined
> window.c
undefined
~~~

非ブラウザ環境にはwindowは無いでしょうが,
Nodeはそもそもrequireがありますし,
大概の環境でwindowに相当するグローバルオブジェクトがあるでしょう.
Web Workerなら([WorkerGlobalScope.self](https://developer.mozilla.org/ja/docs/Web/API/WorkerGlobalScope/self))とか.
ない場合(ないことがあるのか?)はそもそもグローバル変数作れないので気にする必要なし.

ユニバーサルJavaScriptにしたい?
requireもimportもなしにユニバーサルJavaScript作るのは無理ではないでしょうか.

# typeofでもネストしたフィールドを参照するとTypeErrorになるので混乱の元になる

やっと本題です.

~~~js
> table = {user: 'ncaq', friends: null}
{ user: 'ncaq', friends: null }
> typeof table.friends[0]
TypeError: Cannot read property '0' of null
~~~

typeofはネストしたプロパティを辿ると普通に例外を出します.

1段目は無問題という油断が今回のバグを生み出し,記事を書く動機になりました.

typeofには頼れないので1つ1つnullケアしていきましょう.

# nullチェックがつらい

JavaScriptでエラーを返さずにネストした値のnullチェックを行う良い標準的な方法が存在しない.

[Lodashのget](https://lodash.com/docs/4.17.10#get)のようなものでも,
文字列渡しでチェックしていてスマートじゃないですね.

JavaScriptにはマクロがないのでどうしてもこうなってしまう.

[tc39/proposal-optional-chaining](https://github.com/tc39/proposal-optional-chaining)が入ればチェックも少しは楽になるのですが.

null排除にはTypeScriptかFlowかReasonかPureScriptかElmを使うべきですね.
JavaScriptのつらさを改めて実感しました.
